<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 99.2beta5 (1.38)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>GNU OCTAL OX_API Developer's Guide</TITLE>
<META NAME="description" CONTENT="GNU OCTAL OX_API Developer's Guide">
<META NAME="keywords" CONTENT="ox_api_main">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v99.2beta5">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="ox_api_main.css">

</HEAD>

<BODY >
<!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive"
 SRC="file:/usr/local/lib/latex2html/icons/nx_grp_g.png"> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="file:/usr/local/lib/latex2html/icons/up_g.png"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="file:/usr/local/lib/latex2html/icons/prev_g.png">   
<BR>
<BR>
<BR>
<!--End of Navigation Panel-->

<P>
<H1 ALIGN="CENTER"><TT>GNU</TT> <TT>OCTAL</TT> 
<BR><TT>OX_API</TT> Developer's Guide</H1>
<P ALIGN="CENTER"><STRONG>David T. O'Toole (dto@gnu.org)</STRONG></P>

<P>
<BR>

<H2><A NAME="SECTION00100000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html54"
 HREF="ox_api_main.html">Contents</A>
<UL>
<LI><A NAME="tex2html55"
 HREF="ox_api_main.html#SECTION00110000000000000000">Introduction</A>
<UL>
<LI><A NAME="tex2html56"
 HREF="ox_api_main.html#SECTION00111000000000000000">Obtaining GNU Octal</A>
</UL>
<LI><A NAME="tex2html57"
 HREF="ox_api_main.html#SECTION00120000000000000000">Copyright and License Information</A>
<LI><A NAME="tex2html58"
 HREF="ox_api_main.html#SECTION00130000000000000000">Recent API Changes</A>
</UL>
<LI><A NAME="tex2html59"
 HREF="ox_api_main.html#SECTION00200000000000000000">Using OX_API</A>
<UL>
<LI><A NAME="tex2html60"
 HREF="ox_api_main.html#SECTION00210000000000000000">Terminology</A>
<LI><A NAME="tex2html61"
 HREF="ox_api_main.html#SECTION00220000000000000000">Including the machine interface</A>
<LI><A NAME="tex2html62"
 HREF="ox_api_main.html#SECTION00230000000000000000">Describing your parameters and controls</A>
<LI><A NAME="tex2html63"
 HREF="ox_api_main.html#SECTION00240000000000000000">Creating a machine type and telling the host about yourself</A>
<LI><A NAME="tex2html64"
 HREF="ox_api_main.html#SECTION00250000000000000000">Maintaining state (raw C only)</A>
<LI><A NAME="tex2html65"
 HREF="ox_api_main.html#SECTION00260000000000000000">Setting up your callbacks</A>
<UL>
<LI><A NAME="tex2html66"
 HREF="ox_api_main.html#SECTION00261000000000000000">ox_init: one-time startup</A>
<LI><A NAME="tex2html67"
 HREF="ox_api_main.html#SECTION00262000000000000000">ox_create: manufacturing new machines</A>
<LI><A NAME="tex2html68"
 HREF="ox_api_main.html#SECTION00263000000000000000">ox_destroy: destroying machines</A>
<LI><A NAME="tex2html69"
 HREF="ox_api_main.html#SECTION00264000000000000000">ox_work: processing and generating </A>
<LI><A NAME="tex2html70"
 HREF="ox_api_main.html#SECTION00265000000000000000">ox_event: when parameter values change</A>
<LI><A NAME="tex2html71"
 HREF="ox_api_main.html#SECTION00266000000000000000">ox_desc: giving text feedback </A>
</UL>
<LI><A NAME="tex2html72"
 HREF="ox_api_main.html#SECTION00270000000000000000">Writing a Generator</A>
<UL>
<LI><A NAME="tex2html73"
 HREF="ox_api_main.html#SECTION00271000000000000000">ox_channel: preparing voices for use in polyphony</A>
<LI><A NAME="tex2html74"
 HREF="ox_api_main.html#SECTION00272000000000000000">Standard parameter positions</A>
</UL>
<LI><A NAME="tex2html75"
 HREF="ox_api_main.html#SECTION00280000000000000000">OX_API Package: Access to the Core</A>
<UL>
<LI><A NAME="tex2html76"
 HREF="ox_api_main.html#SECTION00281000000000000000">Musical Utility</A>
<LI><A NAME="tex2html77"
 HREF="ox_api_main.html#SECTION00282000000000000000">Environment</A>
<LI><A NAME="tex2html78"
 HREF="ox_api_main.html#SECTION00283000000000000000">Memory allocation</A>
</UL>
<LI><A NAME="tex2html79"
 HREF="ox_api_main.html#SECTION00290000000000000000">Being flattened</A>
<LI><A NAME="tex2html80"
 HREF="ox_api_main.html#SECTION002100000000000000000">Compiling with GCC.</A>
<LI><A NAME="tex2html81"
 HREF="ox_api_main.html#SECTION002110000000000000000">Wavetable Extension and Wavemaps</A>
<LI><A NAME="tex2html82"
 HREF="ox_api_main.html#SECTION002120000000000000000">Interface Layout Extension</A>
</UL>
<LI><A NAME="tex2html83"
 HREF="ox_api_main.html#SECTION00300000000000000000">Using ox_wrappers</A>
<UL>
<LI><A NAME="tex2html84"
 HREF="ox_api_main.html#SECTION00310000000000000000">Overview</A>
<LI><A NAME="tex2html85"
 HREF="ox_api_main.html#SECTION00320000000000000000">class OX_Machine</A>
<LI><A NAME="tex2html86"
 HREF="ox_api_main.html#SECTION00330000000000000000">Setting things up</A>
</UL>
<LI><A NAME="tex2html87"
 HREF="ox_api_main.html#SECTION00400000000000000000">OX_API Reference</A>
<UL>
<LI><A NAME="tex2html88"
 HREF="ox_api_main.html#SECTION00410000000000000000">Typedefs</A>
<UL>
<LI><A NAME="tex2html89"
 HREF="ox_api_main.html#SECTION00411000000000000000">samp (octal.h)</A>
<LI><A NAME="tex2html90"
 HREF="ox_api_main.html#SECTION00412000000000000000">param (octal.h)</A>
</UL>
<LI><A NAME="tex2html91"
 HREF="ox_api_main.html#SECTION00420000000000000000">Structures</A>
<UL>
<LI><A NAME="tex2html92"
 HREF="ox_api_main.html#SECTION00421000000000000000">struct machine_type</A>
<LI><A NAME="tex2html93"
 HREF="ox_api_main.html#SECTION00422000000000000000">struct machine</A>
<LI><A NAME="tex2html94"
 HREF="ox_api_main.html#SECTION00423000000000000000">struct param_spec</A>
</UL>
<LI><A NAME="tex2html95"
 HREF="ox_api_main.html#SECTION00430000000000000000">Catalog of parameter types and widgets</A>
<LI><A NAME="tex2html96"
 HREF="ox_api_main.html#SECTION00440000000000000000">Required Prototypes for C Callbacks</A>
<LI><A NAME="tex2html97"
 HREF="ox_api_main.html#SECTION00450000000000000000">Package Functions</A>
</UL></UL>
<!--End of Table of Contents-->
<P>

<H1><A NAME="SECTION00110000000000000000">
Introduction</A>
</H1>

<P>
This manual shows how to create audio plugins for GNU Octal in C or C++. 

<P>
OCTAL is a GNU project (started in 1999) to create a free music system based
on unit generator synthesis, sampling, and audio-plugin technology. It consists
of:

<P>

<OL>
<LI>A music-systems plugin API, used to define sound processing objects called
"machines" that users may download from the web to use as instruments or
effects in their compositions.
</LI>
<LI>A core component to load these machines, communicate with them, route and mix
audio signals between them, and produce output on an audio device.
</LI>
<LI>A graphical user interface (using the Gimp Toolkit) to interactively create,
compose, and perform music using the core as a backend.
</LI>
<LI>An open file format for saving these compositions and the associated resources
(sound samples, plugin machines) that comprise them.
</LI>
</OL>

<P>
The <TT>OCTAL</TT> project homepage (URL below) includes a more
detailed overview, as well as current release code and
documentation. There is also a mailing list called <TT>octal-dev</TT>.

<P>
Visit the <TT>OCTAL</TT> home page at <TT>http://www.gnu.org/software/octal</TT>

<P>

<H2><A NAME="SECTION00111000000000000000">
Obtaining GNU Octal</A>
</H2>

<P>
Tarball releases are periodically placed in <TT>ftp://ftp.gnu.org/gnu/octal.</TT>
The latest development versions are available via CVS. The following commands
will do an anonymous checkout:

<P>
<PRE>
cvs -d:pserver:anoncvs@subversions.gnu.org:/cvsroot/octal login
 
cvs -z3 -d:pserver:anoncvs@subversions.gnu.org:/cvsroot/octal co octal
</PRE>

<P>

<H1><A NAME="SECTION00120000000000000000">
Copyright and License Information</A>
</H1>
Copyright &#169; 2000, 2001 by David O'Toole <TT>(dto@gnu.org)</TT>.
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections.

<P>
The included file <TT>DOC_COPYING</TT> contains the text of the
	license. If for some reason this file is missing, a copy of
	the license is available online at 

<P>
<TT>http://www.gnu.org/copyleft/fdl.html</TT>

<P>

<H1><A NAME="SECTION00130000000000000000">
Recent API Changes</A>
</H1>

<P>
<DL>
<DT><STRONG>C++ Wrapper Tweak.</STRONG></DT>
<DD>The <TT>pkg</TT> member has been renamed ``core'', so
that both C and C++ machines can access package functions as <TT>core-&gt;name()</TT>. C machines need no changes, but will have to declare a local
handle if they wish to use the above
convention, which is simpler than <TT>m-&gt;pkg-&gt;name()</TT>.
See <A HREF="ox_api_main.html#corehandle">1.8</A>.)
</DD>
<DT><STRONG>Stringified Parameters.</STRONG></DT>
<DD>Direct use of <TT>struct param_spec</TT> by
machines is no longer needed. Instead, you can use an array of formatted
strings to specify your machine's parameters. See the section on parameters for
more details. 
</DD>
<DT><STRONG>Floating-point Parameters.</STRONG></DT>
<DD>All parameter data is now stored in
floating-point format. This eliminates having to convert from some integer
range into ``nice'' numbers used in DSP. Simply specify the range you need. 
</DD>
<DT><STRONG>Name Changes.</STRONG></DT>
<DD><TT>ox_update()</TT> has been renamed <TT>ox_event()</TT>. Its
parameter list has not changed. The <TT>ox_track</TT> API has changed into <TT>ox_channel</TT> and is part of the new voice architecture. See the section on
polyphony for more information. 
</DD>
</DL>

<P>

<P>

<H1><A NAME="SECTION00200000000000000000">
Using <TT>OX_API</TT></A>
</H1>  

<P>
This chapter presents a quick run-through of how to set up
communication between <TT>OCTAL</TT> and your plugin using the C programming
language. 

<P>

<H1><A NAME="SECTION00210000000000000000">
Terminology</A>
</H1>

<P>
This section defines most of the important terms used in the rest of
the document, focusing on those associated with new unit-generator
based music systems like <TT>OCTAL</TT>.

<P>
<DL>
<DT><STRONG>Machine.</STRONG></DT>
<DD>A machine is an object which processes or generates audio
signals. These are the basic building blocks of a signal network, in which
machines that generate signals route their audio through other machines, and so
on. <B>Generators</B> are machines that primarily create sound and send it for
further processing; <B>effects</B> typically process an input stream.

<P>
</DD>
<DT><STRONG>Parameter.</STRONG></DT>
<DD>Parameters are data items that can be recieved by machines
to control their generation/processing of audio. Things like ``note'', ''cutoff
frequency'', and ''waveform'' might be parameters in your machine. Anything
about your machine that can be controlled can be a parameter.

<P>
</DD>
<DT><STRONG>Event.</STRONG></DT>
<DD>In general, an event is a change in the value of a parameter on a
particular channel. 

<P>
</DD>
<DT><STRONG>Channel.</STRONG></DT>
<DD>An <TT>OX_API</TT> channel is the main method of implementing polyphonic
generator machines. A channel is a distinct voice in your machine. A synth may
wish to play multiple notes at the same time, while still being able to control
generation parameters for each note individually. Thus each note goes into its
own channel. 

<P>
</DD>
<DT><STRONG>Pattern.</STRONG></DT>
<DD>A pattern is a sequence of events for a machine. Patterns may
include melodies, volume changes, or any other kind of event the machine
supports.  

<P>
</DD>
<DT><STRONG>Control widget.</STRONG></DT>
<DD>A control widget is anything that lets you
interactively change the value of a parameter on a given machine. For instance,
a graphical slider is a control widget.

<P>
</DD>
<DT><STRONG>Block.</STRONG></DT>
<DD>The continous audio output of <TT>OCTAL</TT> is generated in small
blocks of a few hundred samples at a time. The block size changes dynamically.

<P>
</DD>
</DL>

<P>

<H1><A NAME="SECTION00220000000000000000">
Including the machine interface</A>
</H1>

<P>
 <BLOCKQUOTE>
<DIV ALIGN="LEFT">
<TT> 
        #include "machine.h"  
</TT></DIV>
</BLOCKQUOTE> 

<P>
This file defines the structures and constants you'll need to interface with
Octal. 

<P>

<H1><A NAME="SECTION00230000000000000000">
Describing your parameters and controls</A>
</H1>

<P>
<A NAME="parameters"></A>
<H4><A NAME="SECTION00230010000000000000">
Indexing.</A>
</H4> Each of your machine's parameters is identified by a numeric index,
starting at zero. First, let's set up some symbolic constants to make
these indices easier to remember.

<P>
This can be done very easily with C's enumerated type facility:

<P><PRE>
enum {ix_first_param, ix_second_param, ... }
</PRE>

<P>
The <TT>ix_</TT> stands for ``index.'' It's just a convention that makes
the meaning of the name more clear. You should name the constants in
accordance with the parameter's use; for instance, the example
delay machine uses <TT>ix_length</TT> and <TT>ix_feedback.</TT>

<P>

<H4><A NAME="SECTION00230020000000000000"></A> <A NAME="paramspecs"></A>
<BR>
Parameter info.
</H4> 

<P>
Octal needs some information about each of your machine's parameters.  In
particular, we need a name; what type of parameter it is; what kind of widget
to use when opening a control box; a short description of the parameter that
can be displayed to the user; and information about the acceptable ranges and
default values for the parameter.

<P>
We can pack this information into a string with the following format:
<PRE>
|name|description|type|widget|minvalue|maxvalue|defaultvalue|
</PRE>
Create a null-terminated array of strings, one for each parameter:

<P><PRE>
char *my_params[] = {
        "|note|Which note to play|note|slider|0|128|0",
        "|vol|Volume 0.0-1.0|generic|slider|0|1.0|0.6",
        NULL    		
};
</PRE>

<P>
(Be sure to put the strings in the same order as the enumeration constants you
set up earlier.) By describing them abstractly instead of in terms of graphics
calls and windows, your machine can remain independent of GUI specifics.

<P>
For a catalog of parameter types and widgets you can
choose from, consult <A HREF="ox_api_main.html#paramtable">3.3</A> (p.
<A HREF="ox_api_main.html#paramtable"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="file:/usr/local/lib/latex2html/icons/crossref.png"></A>).

<P>

<H1><A NAME="SECTION00240000000000000000">
Creating a machine type and telling the host about yourself</A>
</H1>

<P>
<A NAME="yourself"></A> <TT>OCTAL's</TT> <TT>machine_type</TT> structure holds
information about the kind of machine you're making. As a machine developer,
you'll need to fill in some of its fields. You'll need a long name (including
the author's name), a short name (like ``delay'' or ``sampler''), the maximum
number of channels (if any), and the address of the string array that describes
your parameters.

<P>
You'll also need to tell Octal about your input and output channels.
One and two are <TT>mono</TT> and <TT>stereo</TT>, respectively. Zero input channels
would mean that your machine is a ``pure generator'' which does not
accept any audio input.

<P>
Section <A HREF="ox_api_main.html#ox_init">1.6.1</A> shows an example. 

<P>

<H1><A NAME="SECTION00250000000000000000">
Maintaining state (raw C only)</A>
</H1> 

<P>
Your machine library will be called upon to do the processing for many
<B>machine instances.</B> After all, the musician may want to create
more than one delay machine, or more than one sampler machine, each
doing its own thing and playing its own sequences.

<P>
<TT>OCTAL</TT> uses the <TT>machine</TT> structure to represent each machine
instance, regardless of type. (The system keeps track of which type
each machine instance has.) Since each machine type will need to store
different kinds of data, we'll need to define a new structure type
that is unique to the new machine type.

<P>
<TT>OCTAL</TT> calls these <B>state objects.</B> Each machine can have a state
object associated with it. Struct <TT>machine</TT> has a <TT>void*</TT>
member called <TT>state</TT> which you can use to store the address of a
state object.

<P>
Some of this bookkeeping can be hidden using the included <TT>ox_wrappers.</TT>
This is a C++ wrapper for the <TT>OX_API</TT>. Class and member function facilities hide
the management of state objects completely. See this document's chapter on <TT>ox_wrappers.</TT>

<P>

<H1><A NAME="SECTION00260000000000000000">
Setting up your callbacks</A>
</H1>

<P>
Each octal machine library must export seven specially named callback
functions. This section details when and how these functions are called by the
host, as well as what to do (and what not to do) when this happens.

<P>

<H2><A NAME="SECTION00261000000000000000"></A>
<A NAME="ox_init"></A>
<BR>
ox_init: one-time startup
</H2>

<P>
 <BLOCKQUOTE>
<DIV ALIGN="LEFT">
<TT> int ox_init(machine_type* t)  
</TT></DIV>
</BLOCKQUOTE> 

<P>
This function is called when your shared library is first loaded. <TT>OCTAL</TT> 
will pass you the address of a machine_type structure. You must fill in
several fields with the appropriate data<A NAME="tex2html1"
 HREF="ox_api_main.html#foot198"><SUP>1.1</SUP></A>. You may also perform any other
one-time initialization tasks here, such as precomputing a large
lookup table, loading a special configuration file, etcetera.

<P>
Here is a quick example of how to fill in the structure, taken from the example
square wave generator machine included in the <TT>OCTAL</TT> distribution: 

<P><PRE>
  t-&gt;long_name        = "David's Simple Squarewave Machine"; 
  t-&gt;short_name       = "dtosquare"; 
  t-&gt;max_channels     = 1; 
  t-&gt;input_channels   = 1; 
  t-&gt;output_channels  = 1;   

  // give it the array of strings we declared above
  t-&gt;param_info       = my_params;
</PRE>

<P>

<H2><A NAME="SECTION00262000000000000000"></A>
<A NAME="ox_create"></A>
<BR>
ox_create: manufacturing new machines
</H2>
 <BLOCKQUOTE>
<DIV ALIGN="LEFT">
<TT>void ox_create(machine* m) 
</TT></DIV>
</BLOCKQUOTE> 

<P>
When the user creates a new machine instance of your type, the host
will call this function with the address of the new <TT>machine</TT>
struct.

<P>
Your job during ox_create() is as follows is to set up the machine
instance and get it ready to run.

<P>

<UL>
<LI>Allocate a new state object using <TT>package::alloc()</TT><A NAME="tex2html2"
 HREF="ox_api_main.html#foot342"><SUP>1.2</SUP></A> 
</LI>
<LI>Associate the new state object with the machine by assigning its
  address to <TT>m-&gt;state</TT> 
</LI>
<LI>Don't worry about setting param defaults or creating a default channel--the host will do this after you <TT>return.</TT> 
</LI>
</UL>

<P>
If you're not using state objects, you can skip most of those steps. Your
class constructor will be called by <TT>ox_wrappers.</TT>

<P>
Here's an example:

<P>
 <BLOCKQUOTE>
<DIV ALIGN="LEFT">
<TT>
my_state *s; 
<BR>... 
<BR>
do_something_with(s); 
<BR>
m-&gt;state = (void*)s; 
<BR> 
</TT></DIV>
</BLOCKQUOTE> 

<P>

<H2><A NAME="SECTION00263000000000000000">
ox_destroy: destroying machines</A>
</H2>

<P>
The opposite of <TT>ox_create().</TT> If you normally create a state object or
allocate any memory buffers for a machine, now is the time to free that memory,
and then free the state object itself. Be sure to use <TT>package::free()</TT>, the
memory deallocation wrapper.

<P>

<H2><A NAME="SECTION00264000000000000000">
ox_work: processing and generating </A>
</H2>

<P>
 <BLOCKQUOTE>
<DIV ALIGN="LEFT">
<TT>int ox_work(machine* m, int block_size) 
</TT></DIV>
</BLOCKQUOTE> 

<P>
This is where the actual work happens; hence the name. First, grab your state
object by casting <TT>m-&gt;state</TT> to whatever pointer type you are using for
your state objects.

<P>
 <BLOCKQUOTE>
<DIV ALIGN="LEFT">
<TT>my_state *s = (my_state*) m-&gt;state;  
</TT></DIV>
</BLOCKQUOTE> 

<P>
Your parameters will have been set during the host's call to <TT>ox_event().</TT> The number of samples you should generate for this block is held
in the <TT>block_size </TT> argument.  Begin processing. Your input
buffers will be arrays of type <TT>samp.</TT> <TT>m-&gt;lin</TT> and <TT>m-&gt;rin</TT> are
the left and right input buffers<A NAME="tex2html3"
 HREF="ox_api_main.html#foot227"><SUP>1.3</SUP></A>, while <TT>m-&gt;lout</TT> and <TT>m-&gt;rout</TT> are the output buffers. 

<P>
There will also be an auxiliary input signal set, labeled <TT>xlin/xrin</TT>, for
use in vocoding and other modulation tasks.

<P>
Return <TT>TRUE</TT> if you generated any sound; <TT>FALSE</TT> otherwise. 

<P>

<H2><A NAME="SECTION00265000000000000000">
ox_event: when parameter values change</A>
</H2>

<P><PRE>
void ox_event(machine* m, int channel, 
            int which_param, param value)
</PRE>

<P>
Use this callback to respond to note events and parameter changes, altering the
state of your machine as needed so that the next time your work function is
called, the changes will have taken effect.

<P>
When a parameter's value changes, you'll be called with the channel number,
parameter number, and new parameter value. Your channels are numbered from 0 to
<TT>m-&gt;num_channels - 1</TT>. The parameter indices will match up with the <TT>ix_*</TT> constants you set up earlier. The value is a floating-point number in
the range you specified for that parameter.

<P>
An effect machine can usually ignore the channel number. It is primarily meant to match
up control changes in a pattern with the voice that should recieve them.  

<P>
The value <TT>OX_NOTE_OFF</TT> is a special case for the <TT>note</TT>
parameter type; it means that the note should stop playing on that channel. 

<P>

<H4><A NAME="SECTION00265010000000000000">
Great. But now what do I do with the data?</A>
</H4> 

<P>
You might want to change the state of your machine. For instance, when you
recieve a <TT>OX_NOTE_OFF</TT> value for the note, you may need to update a
variable somewhere that says ``I'm no longer playing any notes on channel
<IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$x$">.''<A NAME="tex2html4"
 HREF="ox_api_main.html#foot343"><SUP>1.4</SUP></A>
<P>
Here is the <TT>ox_event()</TT> function taken from the example square-wave
plugin: 

<P><PRE>
void ox_event(machine* m, int channel, 
               int param_index, param value) 
{
  my_state *s = (my_state*)m-&gt;state; 
  package *core = m-&gt;pkg;
     
  switch(param_index) {

  case ix_note:
    s-&gt;pitch = core-&gt;note2freq(value); 
    if (value = OX_NOTE_OFF) s-&gt;play = 0; 
    else s-&gt;play = 1; 
    break;

  case ix_vol:
    s-&gt;vol = ((float)value) / 255.0;    /* scale to 1.0 */   
    break;
  }
}
</PRE>

<P>

<H2><A NAME="SECTION00266000000000000000">
ox_desc: giving text feedback </A>
</H2>

<P>
 <BLOCKQUOTE>
<DIV ALIGN="LEFT">
<TT>void ox_desc(char* dest, int which_param, param
  value) 
</TT></DIV>
</BLOCKQUOTE> 

<P>
The user needs to know something about how a machine interprets it parameter
values. So, in
addition to the simple naming and description of parameters discussed in
<A HREF="ox_api_main.html#parameters">1.3</A>, the <TT>OX_API</TT> supports ``live'' parameter feedback from the
machines. When the musician tweaks a slider or spin button on your machine,
Octal calls <TT>ox_desc()</TT><A NAME="tex2html5"
 HREF="ox_api_main.html#foot255"><SUP>1.5</SUP></A> with the
location of the buffer where you should write the string, the index number of
the parameter being tweaked, and the new value. Your job is to make up a string
describing the ``interpreted version'' of the new value; for instance, if the
range <IMG
 WIDTH="64" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img2.png"
 ALT="$(0.0, 1.0)$"> is interpreted as a percentage, the following code
will write a string describing the new value into the location pointed to by
<TT>dest.</TT>  <TT>OCTAL</TT> might then display this string onscreen.

<P><PRE>
float x;
int percent;
...
switch(which_param) {
  
  case ix_feedback: 
    percent = (int)(param_value*100.0);
    sprintf(dest, "%d%%", percent);
    break;

  case ix_vol: 
    // describe volume
    ...
</PRE>

<P>
<B>Note:</B> 
It isn't safe to assume that the host's calls to <TT>ox_desc()</TT> will
``pair up'' with parameter changes. While this will often be true,
sometimes there will be no connection between calls.  For instance, to
fill an <TT>option</TT> control with five or six options, OCTAL will
query <TT>ox_desc()</TT> for each choice and retrieve a string to
display for each item in the box.

<P>
You can use C's <TT>enum</TT> facility to create a set of unique indices, and then
<TT>switch</TT><A NAME="tex2html6"
 HREF="ox_api_main.html#foot344"><SUP>1.6</SUP></A> on the <TT>value</TT> passed to you during <TT>ox_desc()</TT>, in each <TT>case</TT> returning the string you would like to have
appear in the interface. This indexing strategy is like the one used for
parameters themselves.

<P>

<H1><A NAME="SECTION00270000000000000000">
Writing a Generator</A>
</H1>

<P>
<I>[This section is not yet finished.]</I>

<P>

<H2><A NAME="SECTION00271000000000000000"></A> 
<A NAME="multitrack"></A>
<BR>
ox_channel: preparing voices for use in polyphony
</H2>

<P>
 <BLOCKQUOTE>
<DIV ALIGN="LEFT">
<TT>void ox_channel(machine* m, int creating, int channel_number) 
</TT></DIV>
</BLOCKQUOTE> 

<P>

<H2><A NAME="SECTION00272000000000000000">
Standard parameter positions</A>
</H2>

<P>

<H1><A NAME="SECTION00280000000000000000">
<TT>OX_API</TT> Package: Access to the Core</A>
</H1>
The <TT>OX_API</TT> package is a set of callback API functions that you can use to
request information or services from <TT>OCTAL</TT>. Make a local handle to the core
package by doing this:
<A NAME="corehandle"></A><PRE>
    package *core = m-&gt;pkg;
</PRE>

<P>
Then you may call any package function through this handle. For instance, to
convert a note value to a frequency in the current system tuning, use

<P>
<PRE>
    float f = core-&gt;note2freq();
</PRE>  

<P>
The following sections give the prototypes of other functions. 

<P>

<H2><A NAME="SECTION00281000000000000000">
Musical Utility</A>
</H2>

<P>
<PRE>
float note2freq (param n);

float text2freq (const char *text);
param text2note (const char *text);
const char *note2text (param note);
</PRE>

<P>

<H2><A NAME="SECTION00282000000000000000">
Environment</A>
</H2>
Sometimes you will need configuration information from the host, like the
current sampling rate, tempo, song position, etcetera. You can use these
functions to retrieve the data:

<P>
<PRE>
int get_sr(void); 	// sampling rate
</PRE>

<P>

<H2><A NAME="SECTION00283000000000000000"></A><A NAME="memory"></A>
<BR>
Memory allocation
</H2>

<P>
There are special restrictions on memory allocation for <TT>OCTAL</TT> machines. First, you may only allocate memory during <TT>ox_create</TT> and
<TT>ox_channel.</TT> Second, you must use the provided wrappers for allocating memory
rather than calling <TT>malloc</TT> and <TT>free</TT> directly. They wrappers reside
in the <TT>OX_API</TT> package along with other utility functions:

<P>
<PRE>
void *alloc(size); 
void free(ptr);
</PRE>

<P>
As in the other examples, <TT>m</TT> is the pointer to your machine structure. 

<P>

<H1><A NAME="SECTION00290000000000000000"></A>
<A NAME="flattened"></A>
<BR>
Being flattened
</H1>
When the user saves his/her song, your machine will need to be saved
to disk. Since <TT>OCTAL</TT> has stored all the patterns of your machine, as
well as kept track of current parameter values, it can save all this
data without your needing to worry about it.

<P>

<H1><A NAME="SECTION002100000000000000000">
Compiling with GCC.</A>
</H1>

<P>
Using the <TT>-shared</TT> option to GCC, you can compile your C source
file into a self-contained shared library (with the suffix <TT>*.so</TT>). Once this is done, <TT>OCTAL</TT> will be able to load and use your
machine. Here's an example of a <B>GNU make</B> command that will
properly compile your machine:

<P>
<PRE>
squaregen.so: squaregen.c machine.h 
    gcc -O3 -g -Wall -shared squaregen.c -o squaregen.so
</PRE>

<P>
<TT>OCTAL's</TT> build system will be able to automatically compile and install
machines for the end user, so a distribution pack consisting of the
machine source and documentation should suffice.

<P>

<H1><A NAME="SECTION002110000000000000000">
Wavetable Extension and Wavemaps</A>
</H1>

<H1><A NAME="SECTION002120000000000000000">
Interface Layout Extension</A>
</H1>

<P>

<H1><A NAME="SECTION00300000000000000000">
Using <TT>ox_wrappers</TT></A>
</H1>

<P>

<H1><A NAME="SECTION00310000000000000000">
Overview</A>
</H1> <TT>OCTAL</TT> includes a package called <TT>ox_wrappers,</TT> which
is designed to simplify <TT>OCTAL</TT> machine programming through the use of
syntactic features of <TT>C++.</TT> This section only explains the differences
between raw <TT>OX_API</TT> programming and <TT>ox_wrappers</TT>, so it will help to have
read the chapter on <TT>OX_API</TT> first. 

<P>
In a nutshell, your machine type is now a class; individual machines are now
instances of that class. This lets you have data members, utility classes, and
all the interesting features of C++ at your disposal to create machines.

<P>

<H1><A NAME="SECTION00320000000000000000">
<TT>class OX_Machine</TT></A>
</H1>

<P>
<TT>ox_wrappers.h</TT> declares a base class called <TT>OX_Machine,</TT> from which
you'll derive a new class that implements your machine. Here is its definition:

<P>
<PRE>
// class OX_Machine just defines the interface to keep things
// consistent.  none of its member functions will ever be called,
// because calls to the derived class will all be statically bound 

class OX_Machine {
        public: 
        OX_Machine(machine* m) {};        
        ~OX_Machine() {};

        static int initialize(machine_type* t) {};   
        static void describe(char* dest, int which, param value) {}; 

        void event(int channel, int which, param value) {};           
        int work(int block_size) {}; 
        int channel(int creating, int channel_number) {};
        
        // you typically won't need to access this next field from C++
        machine* m; 

        // package functions and i/o buffers
        package* core; 
        samp *lin, *rin, *lout, *rout; 
};
</PRE>

<P>
It's not hard to see that the member functions are just like the <TT>ox_*</TT>
callbacks, but with the ``machine*'' pointer removed from the argument
lists.<A NAME="tex2html7"
 HREF="ox_api_main.html#foot347"><SUP>2.1</SUP></A> <TT>ox_create</TT> and <TT>ox_destroy</TT> are now the
constructor<A NAME="tex2html8"
 HREF="ox_api_main.html#foot348"><SUP>2.2</SUP></A> and destructor,
respectively.

<P>
The frequently-accessed i/o buffer pointers <TT>rin, lin, lout, rout</TT> are
members of the class, so they can be accessed in member functions without any
explicit dereferencing. 

<P>
Instead of state objects, you can simply add data members to your derived
class.

<P>

<H1><A NAME="SECTION00330000000000000000">
Setting things up</A>
</H1>

<P>
Now is the slightly weird part. Step one: define the macro <TT>OX_CLASS</TT> to
be the name of your new derived class. If your class is called <TT>MyCoolDelay</TT>, then  <BLOCKQUOTE>
<DIV ALIGN="LEFT">
<TT>#define OX_CLASS MyCoolDelay 
</TT></DIV>
</BLOCKQUOTE> 

<P>
It's important to do this before you include any <TT>ox_wrappers</TT> header
files. The reason is that new functions, making statically-bound calls to your
new member functions, are going to be created when you compile. 

<P>
Next, derive your class from <TT>OX_Machine</TT> and place its declaration in,
say, <TT>MyCoolDelay.h</TT> Then do the following:

<P>
<PRE>
#define OX_CLASS MyCoolDelay
#include ``ox_wrappers.h''
#include ``MyCoolDelay.h''
#include ``ox_wrappers.cc''
</PRE>

<P>
Now implement your member functions, and compile as a shared object. The
wrapper will export the required <TT>OX_API</TT> functions with C linkage, so that
<TT>OCTAL</TT> will be able to find them. When <TT>OCTAL</TT> calls them, <TT>ox_wrappers</TT>
will forward the relevant info on to your machine. 

<P>
You'll still have to use some C structures such as <TT>machine_type</TT>
when communicating with <TT>OCTAL</TT>. Your class inherits a data member
<TT>m</TT>, which is a pointer to the underlying <TT>struct machine</TT> object that
<TT>OCTAL</TT> is dealing with directly.

<P>
All the information in <A HREF="ox_api_main.html#parameters">1.3</A>, <A HREF="ox_api_main.html#yourself">1.4</A>, and <A HREF="ox_api_main.html#flattened">1.9</A>
applies to use of <TT>ox_wrappers.</TT> You might need to override the new and
delete operators so that they call the <TT>OX_API</TT> wrappers. 

<H1><A NAME="SECTION00400000000000000000">
<TT>OX_API</TT> Reference</A>
</H1> 

<P>
<I>[This chapter is not yet complete.]</I>

<P>

<H1><A NAME="SECTION00410000000000000000">
Typedefs</A>
</H1>

<P>

<H2><A NAME="SECTION00411000000000000000">
samp (octal.h)</A>
</H2>

<P>
A signed floating-point data type for processing samples. <TT>OCTAL</TT> plugin audio
streams must be in this format. Audio data should be scaled from <IMG
 WIDTH="37" HEIGHT="28" ALIGN="MIDDLE" BORDER="0"
 SRC="img3.png"
 ALT="$-1.0$"> to
<IMG
 WIDTH="37" HEIGHT="28" ALIGN="MIDDLE" BORDER="0"
 SRC="img4.png"
 ALT="$+1.0$">. (The range for control data sent through AUX connections is user-defined.)

<P>

<H2><A NAME="SECTION00412000000000000000">
param (octal.h)</A>
</H2>

<P>
An floating-point type for storing event data. <TT>OCTAL</TT> 
patterns are stored in this format. See the section on <TT>ox_event()</TT> for more information.

<P>

<H1><A NAME="SECTION00420000000000000000">
Structures</A>
</H1>

<P>
<I>[Not yet finished.]</I>

<P>

<H2><A NAME="SECTION00421000000000000000">
struct machine_type</A>
</H2>

<P>

<H2><A NAME="SECTION00422000000000000000">
struct machine</A>
</H2>

<P>

<H2><A NAME="SECTION00423000000000000000">
struct param_spec</A>
</H2>

<P>

<H1><A NAME="SECTION00430000000000000000">
Catalog of parameter types and widgets</A>
</H1> 

<P>
<A NAME="paramtable"></A><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">type</TD>
<TD ALIGN="LEFT">meaning</TD>
<TD ALIGN="LEFT">example</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>note</TT></TD>
<TD ALIGN="LEFT">a musical note</TD>
<TD ALIGN="LEFT">C-4, D#2, B-5</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>velocity</TT></TD>
<TD ALIGN="LEFT">the pressure on a given note</TD>
<TD ALIGN="LEFT">0-128</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>trigger</TT></TD>
<TD ALIGN="LEFT">one-off event trigger</TD>
<TD ALIGN="LEFT">0, 1</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>wave</TT></TD>
<TD ALIGN="LEFT">a raw sound from the wavetable</TD>
<TD ALIGN="LEFT"><TT>3C, 05</TT></TD>
</TR>
</TABLE>	

<P>

<H4><A NAME="SECTION00430010000000000000">.</A>

</H4>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">widget name</TD>
<TD ALIGN="LEFT">description</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>slider</TT></TD>
<TD ALIGN="LEFT">a small slider bar with a handle</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">and displayed numeric value</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>entry</TT></TD>
<TD ALIGN="LEFT">a numeric entry box with ``enter'' button</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>button</TT></TD>
<TD ALIGN="LEFT">a trigger button</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>spin</TT></TD>
<TD ALIGN="LEFT">spin button</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>option</TT></TD>
<TD ALIGN="LEFT">pulldown box with named options</TD>
</TR>
</TABLE>

<P>

<H1><A NAME="SECTION00440000000000000000">
Required Prototypes for C Callbacks</A>
</H1>

<P>
<PRE>
        int         ox_init(machine_type* t)
        void        ox_create(machine* m)
        int         ox_destroy(machine* m)
        void        ox_work(machine* m, int block_size)
        void        ox_event(machine* m, int channel,
                              int which_param, param newvalue)
        void        ox_desc(char* dest, int which, param value)
        void        ox_channel(machine* m, int creating, 
                              int channel_number)
</PRE>

<P>

<H1><A NAME="SECTION00450000000000000000">
Package Functions</A>
</H1>
<I>[This section will cover memory allocators, wavetable functions,
and more when finished.]</I> 

<P>

<H1><A NAME="SECTION00500000000000000000">
About this document ...</A>
</H1>
 <STRONG><TT>GNU</TT> <TT>OCTAL</TT> 
<BR><TT>OX_API</TT> Developer's Guide</STRONG><P>
This document was generated using the
<A HREF="http://www-dsed.llnl.gov/files/programs/unix/latex2html/manual/"><STRONG>LaTeX</STRONG>2<tt>HTML</tt></A> translator Version 99.2beta5 (1.38)
<P>
Copyright &#169; 1993, 1994, 1995, 1996,
<A HREF="http://cbl.leeds.ac.uk/nikos/personal.html">Nikos Drakos</A>, 
Computer Based Learning Unit, University of Leeds.
<BR>
Copyright &#169; 1997, 1998, 1999,
<A HREF="http://www.maths.mq.edu.au/~ross/">Ross Moore</A>, 
Mathematics Department, Macquarie University, Sydney.
<P>
The command line arguments were: <BR>
 <STRONG>latex2html</STRONG> <TT>-split 0 ox_api_main.tex</TT>
<P>
The translation was initiated by David O'Toole on 2001-04-07
<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot198">... data</A><A NAME="foot198"
 HREF="ox_api_main.html#tex2html1"><SUP>1.1</SUP></A>
<DD>Don't fill in fields besides
those listed.

<DT><A NAME="foot342">...<TT>package::alloc()</TT></A><A NAME="foot342"
 HREF="ox_api_main.html#tex2html2"><SUP>1.2</SUP></A>
<DD>See <A HREF="ox_api_main.html#memory">1.8.3</A> for more information on these functions.

<DT><A NAME="foot227">... buffers</A><A NAME="foot227"
 HREF="ox_api_main.html#tex2html3"><SUP>1.3</SUP></A>
<DD>If your machine only accepts a mono
input, they'll both point to the same buffer.

<DT><A NAME="foot343">....''</A><A NAME="foot343"
 HREF="ox_api_main.html#tex2html4"><SUP>1.4</SUP></A>
<DD>This can be used for optimization; if your machine is not
currently playing any notes, it can free up processor time by doing nothing
during <TT>ox_work()</TT> and returning <TT>0.</TT>

<DT><A NAME="foot255">...<TT>ox_desc()</TT></A><A NAME="foot255"
 HREF="ox_api_main.html#tex2html5"><SUP>1.5</SUP></A>
<DD>Note that this function is not called in
reference to any particular machine instance. It is ``library-wide.''

<DT><A NAME="foot344">...<TT>switch</TT></A><A NAME="foot344"
 HREF="ox_api_main.html#tex2html6"><SUP>1.6</SUP></A>
<DD>Because <TT>param</TT> is defined as a floating-point data
type, you will have to cast it to (int) when using it in any switch statement
or array subscript expressions.

<DT><A NAME="foot347">...
lists.</A><A NAME="foot347"
 HREF="ox_api_main.html#tex2html7"><SUP>2.1</SUP></A>
<DD>Since ``initialize'' and ``describe'' are global functions that
don't have to be associated with any particular machine, they're declared <TT>static.</TT>

<DT><A NAME="foot348">...
constructor</A><A NAME="foot348"
 HREF="ox_api_main.html#tex2html8"><SUP>2.2</SUP></A>
<DD>The right constructor takes a <TT>struct machine*</TT> as an
argument; don't use the default no-arg constructor at all.

</DL><HR>
<!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive"
 SRC="file:/usr/local/lib/latex2html/icons/nx_grp_g.png"> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="file:/usr/local/lib/latex2html/icons/up_g.png"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="file:/usr/local/lib/latex2html/icons/prev_g.png">   
<BR>
<!--End of Navigation Panel-->
<ADDRESS>
David O'Toole
2001-04-07
</ADDRESS>
</BODY>
</HTML>
